<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Ajith's web logs]]></title><description><![CDATA[I use this space to log my learnings and occasionally write in-depth articles on Rust, Distributed Systems, and Software Engineering in general.]]></description><link>https://ajithpanneerselvam.github.io/</link><image><url>https://ajithpanneerselvam.github.io/favicon.png</url><title>Ajith&apos;s web logs</title><link>https://ajithpanneerselvam.github.io/</link></image><generator>Ghost 4.36</generator><lastBuildDate>Sat, 26 Feb 2022 14:19:34 GMT</lastBuildDate><atom:link href="https://ajithpanneerselvam.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[WebAssembly, the answer for the Modern Web Performance]]></title><description><![CDATA[<p>This blog was originally published in the <a href="https://medium.com/toyota-connected-india/webassembly-the-answer-for-the-modern-web-performance-c3ab3d1664b5">Toyota Connected Engineering blogs</a>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/image-3.png" class="kg-image" alt loading="lazy" width="864" height="478" srcset="https://ajithpanneerselvam.github.io/content/images/size/w600/2022/02/image-3.png 600w, https://ajithpanneerselvam.github.io/content/images/2022/02/image-3.png 864w" sizes="(min-width: 720px) 720px"><figcaption>Image Credit: <a href="https://github.com/carlosbaraza/web-assembly-logo/tree/master/dist/logo" rel="noopener ugc nofollow">https://github.com/carlosbaraza/web-assembly-logo/tree/master/dist/logo</a></figcaption></figure><p>The Web has evolved so much since its inception, but a few things didn&#x2019;t change much &#x2014; JavaScript. In a rapidly changing Web landscape, JavaScript has</p>]]></description><link>https://ajithpanneerselvam.github.io/webassembly-the-answer-for-the-modern-web-performance/</link><guid isPermaLink="false">6218c591ca7339228dc03c4c</guid><category><![CDATA[WebAssembly]]></category><category><![CDATA[WASM]]></category><category><![CDATA[Rust]]></category><category><![CDATA[Web Browser]]></category><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Ajith]]></dc:creator><pubDate>Thu, 21 Oct 2021 18:30:00 GMT</pubDate><content:encoded><![CDATA[<p>This blog was originally published in the <a href="https://medium.com/toyota-connected-india/webassembly-the-answer-for-the-modern-web-performance-c3ab3d1664b5">Toyota Connected Engineering blogs</a>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/image-3.png" class="kg-image" alt loading="lazy" width="864" height="478" srcset="https://ajithpanneerselvam.github.io/content/images/size/w600/2022/02/image-3.png 600w, https://ajithpanneerselvam.github.io/content/images/2022/02/image-3.png 864w" sizes="(min-width: 720px) 720px"><figcaption>Image Credit: <a href="https://github.com/carlosbaraza/web-assembly-logo/tree/master/dist/logo" rel="noopener ugc nofollow">https://github.com/carlosbaraza/web-assembly-logo/tree/master/dist/logo</a></figcaption></figure><p>The Web has evolved so much since its inception, but a few things didn&#x2019;t change much &#x2014; JavaScript. In a rapidly changing Web landscape, JavaScript has been the only language that ruled the Browser ecosystem for over a quarter-century now. All this speaks for the greatness of JavaScript!</p><p>In recent years, we are pushing the limits of the Web unlike ever before, inviting unconventional web applications built based on Augmented reality (AR), Machine Learning (ML), games demanding intensive graphics, etc. to the web browser. However, JavaScript, the language of the web browser is not meant for building performance-sensitive applications. This is where WebAssembly abbreviated WASM steps into the game, filling the performance void in the web browser.</p><p>WebAssembly has been around there for some time now and it is starting to get serious adoption of late. WebAssembly has found its way beyond web browsers, but we will be talking about <strong>WebAssembly in the scope of the web browser </strong>to keep the article focused.</p><h1 id="understanding-webassembly">Understanding WebAssembly</h1><p>WebAssembly is defined in the <a href="https://webassembly.org/" rel="noopener ugc nofollow">official site </a>as</p><blockquote>WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. WebAssembly is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.</blockquote><p>We will break down the official definition of WebAssembly as we proceed further, but before we delve deeper, let us define it with a simpler language &#x2014; <em><strong>WebAssembly is a technology that enables you to run code written in programming languages other than JavaScript in the web browser. </strong></em>Keep in mind this is not an official definition, but it fits the bill in the context of the web browser. Now we have a layman-level understanding of what WebAssembly is. Let&#x2019;s look at the compilation process and the virtual machine to understand more.</p><h2 id="compilation-process">Compilation Process</h2><p>The idea behind WebAssembly is to take a language like C and run it in the web browser. The C compiler would take the source code and produce machine instructions for the target CPU architecture. But this traditional compilation process is not going to work for the web. Web browsers run on a plethora of platforms that you may not even have come across. We don&#x2019;t know beforehand the underlying CPU architecture where our code is going to run.</p><p>Fortunately, this is not an unprecedented problem in Computer Science. If we look back at the history of Computer Science, it tells us the concept of <strong>Abstraction </strong>has proved to be one of the most powerful mechanisms to reduce platform dependency. WebAssembly does the exact thing &#x2014; it introduces a layer of abstraction, which allows us to run the code in the browser, independent of the underlying platform.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1400/1*Kwmkg4MwwkUaxNX6HJOJeA.png" class="kg-image" alt loading="lazy"><figcaption>WebAssembly Compilation</figcaption></figure><p>As seen in the above diagram, we compile the high-level source code written in languages like C, C++, and Rust and compile it to the intermediate WebAssembly bytecode. Then the WebAssembly bytecode or binary will be shipped along with other website assets like HTML, CSS, and JavaScript files upon loading the web page in the browser. The newly added capability (WebAssembly runtime) in the web browser will take care of translating the WebAssembly bytecode into machine instructions that the underlying processor speaks.</p><p>To run WebAssembly code in the browser, the browser engine will have to implement the WebAssembly specification like how ECMAScript specification is implemented to run JavaScript code. The following is a super simplified diagram of the browser engine focusing only on the runtime components.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1400/1*Ba-V9AWPFXJIwjpjBOnJSA.png" class="kg-image" alt loading="lazy"><figcaption>JavaScript and WebAssembly Runtime</figcaption></figure><p>Each browser has its own browser engine. Hence it is the independent browser team effort to support WebAssembly. It is wonderful that all the major browsers such as Google Chrome, Mozilla Firefox, Safari, and Microsoft Edge have implemented WebAssembly specifications in their browser engine (including the mobile version). At the time of writing this blog, the browsers that support WebAssembly are shown in the image below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1400/1*T8Ce-oWk6HnvdfB24cyxcg.png" class="kg-image" alt loading="lazy"><figcaption>Image Credit &#x2014; <a href="https://caniuse.com/?search=wasm" rel="noopener ugc nofollow">https://caniuse.com/?search=wasm</a></figcaption></figure><p>Okay, enough theory. To get a feel of the WebAssembly bytecode, we are going to use the <a href="https://mbebenita.github.io/WasmExplorer/" rel="noopener ugc nofollow">WebAssembly explorer site </a>to compile a C code to WebAssembly.</p><!--kg-card-begin: html--><script src="https://gist.github.com/AjithPanneerselvam/e1458690bf22ac4ead16b0435a28f6da.js"></script><!--kg-card-end: html--><p>The above code compiled to WebAssembly would look like the bytecode shown below.</p><!--kg-card-begin: html--><script src="https://gist.github.com/AjithPanneerselvam/30180fcb3993398fd51daaba91463145.js"></script><!--kg-card-end: html--><p>If you haven&#x2019;t seen assembly instructions before, this is how it looks :) Definitely not pretty!</p><h2 id="virtual-machine">Virtual Machine</h2><p>The core of WebAssembly is Virtual Machine (VM). Based on the way the instructions are executed, the virtual machines can be broadly classified into two variants &#x2014; register-based and stack-based virtual machines. WebAssembly is a stack-based virtual machine. Stack-based VM executes the instructions using primitive stack operations &#x2014; push and pop. As a result of the simple execution approach, the stack-based instructions are on an average 25% smaller than the equivalent register-based VM instructions. But the space advantage comes at the cost of performance. Yes, it is a space-time tradeoff!</p><p>The Virtual Machine not just makes WebAssembly platform-independent, but also language-independent. Furthermore, the WebAssembly runtime does not have an automatic garbage collector. As a result, languages that do not need garbage collector like C, C++, and Rust got WebAssembly support earlier than other languages that rely on the garbage collector.</p><p>In the scope of Virtual Machines in the browser, Java Applets could be an interesting comparison. Java Applets were primarily used to add interactive features to web applications, and they did a pretty good job given the maturity of the Web at that time. However, there was one serious issue with Java Applets &#x2014; the Java bytecode runs on the Java Virtual Machine (JVM) external to the browser&#x2019;s process memory. This setup prevented Java Applet blend well with the user experience of the web application.</p><p>Operationally, users must maintain two software &#x2014; browser and JVM to run Applets. This was painful as the users must keep the JVM version compatible with Java Applets running in the browser. Parallelly, JavaScript engines were getting a series of optimizations like Just-In-Time (JIT) compilation and access to hardware-accelerated GPU which closed the performance gap between Java Applets and JavaScript. As the disadvantages of Java Applets outweighed the advantages, browsers deprecated the Java Applet support. Now, Java Applet is part of Web history.</p><p>Thanks to the browsers for baking the WebAssembly runtime as the native component in the browser engine.</p><h1 id="when-to-use-webassembly">When to use WebAssembly?</h1><p>If we understand the areas where WebAssembly shines over JavaScript, we can understand when to use it. You would often find people comparing WebAssembly and JavaScript, including myself in this blog. This may allow you to overlook the fundamental traits of WebAssembly and JavaScript. They both are two different things altogether &#x2014; WebAssembly is a compilation target, whereas JavaScript is a programming language. Despite their contrasting traits, they both have a role to play in modern web applications. In the following sections, we will understand the role of WebAssembly by focusing on the key dimensions of any performant web application &#x2014; performance and load time.</p><h2 id="performance">Performance</h2><p>The execution speed is a crucial parameter when we compare JavaScript and WebAssembly. JavaScript is a garbage-collected language. This inherent nature of JavaScript bites us when our web application must perform <strong>CPU-intensive tasks </strong>like audio/video streaming, image rendering, media editing, etc. When we closely look at the mentioned use cases, these are operations proven to be handled effectively by low-level languages such as C, C++, and Rust.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1356/1*xaQ05vsI4IF1O69e-9kolQ.png" class="kg-image" alt loading="lazy"><figcaption>Image Credit: <a href="https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/" rel="noopener ugc nofollow">https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/</a></figcaption></figure><p>In the execution flow of JavaScript, apart from executing the actual instructions, it involves parsing and tokenizing the source code into AST (Abstract Syntax Tree), compiling, optimizing, and garbage collecting. That is a lot of work to be done at runtime! The non-deterministic garbage collection in JavaScript makes the situation worse in performance-sensitive tasks.</p><p>Whereas in WebAssembly, most of the time-consuming execution steps are performed ahead of time at compile time as opposed to what JavaScript does. The decoding and compiling steps in WebAssembly is a lot cheaper because it is already in a language form that is close to what a processor understands. It is evident from the efficient execution pattern, WebAssembly is the answer for the application that craves performance.</p><p>If you are thinking compiling JavaScript to WebAssembly would take the performance gap out of the equation, that is not the case. The current state of WebAssembly runtime only worsens the situation. To compile and run JavaScript as a WebAssembly module, we must compile the whole JavaScript Virtual Machine along with the application code. This takes a huge hit on both the performance and size of the WebAssembly module. This situation may change when the WebAssembly runtime includes garbage collection for languages that rely on it.</p><h2 id="load-time">Load Time</h2><p>The load time of the web page correlates with a good user experience. One factor that influences the load time is the size of the web page assets. The smaller the size of the assets, the quicker the browser downloads and renders them. The size of the WebAssembly module is many times smaller than the equivalent minified JavaScript implementation.</p><p>On top of a smaller WebAssembly module, the streaming compilation feature is an absolute game-changer<em>. </em>Instead of waiting for the whole WebAssembly file to be downloaded, streaming compilation allows the WebAssembly runtime to compile the WebAssembly file in chunks as it downloads them over the network, which reduces the load time multifold.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1000/0*mNQTeL__Y0l1R5x8.gif" class="kg-image" alt loading="lazy"><figcaption>Image Credit: <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/" rel="noopener ugc nofollow">https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/</a></figcaption></figure><h1 id="webassembly-and-javascript-together">WebAssembly and JavaScript together</h1><p>It is easy to overthink that WebAssembly will be replacing JavaScript given the capabilities of WebAssembly. But JavaScript isn&#x2019;t going anywhere. Indeed, WebAssembly complements JavaScript and empowers developers to optimize and run CPU and memory-sensitive applications in the web browser. However, WebAssembly kills the monopoly of JavaScript in the browser space for the good, which opens a whole new set of opportunities.</p><p>In all fairness, WebAssembly cannot do everything JavaScript does. WebAssembly module runs in a sandbox environment, which does not have access to Document Object Model (DOM), I/O, etc. Though this may sound restrictive, the strict isolation eliminates the attack surface the malicious code could exploit. If you intend to perform any I/O operations like a file or network I/O, you must achieve it through JavaScript. This reassures that it is not either WebAssembly or JavaScript, but both have a role to play their strengths in the Web.</p><h2 id="communication-between-webassembly-and-javascript">Communication between WebAssembly and JavaScript</h2><p>The communication between JavaScript and WebAssembly can be an independent article on its own. However, to give you a fair idea, let&#x2019;s talk a little about a key element of the communication between JavaScript and WebAssembly, which is data types.</p><p>WebAssembly has only 4 data types as follows.</p><ul><li>i32: 32-bit integer</li><li>i64: 64-bit integer</li><li>f32: 32-bit floating-point</li><li>f64: 64-bit floating-point</li></ul><p>On the other hand, JavaScript has rich data types like any other high-level language. The disparity between JavaScript and WebAssembly data types leads to questions like, <em>&#x201C;How can a JavaScript String type be represented in WebAssembly?&#x201D;</em>. Any JavaScript data type will be translated down to integers and floating points. Likewise, when the call is made into JavaScript from WebAssembly, the WebAssembly data types will be translated into JavaScript types. Apart from JavaScript APIs, browsers provide Web APIs like <code>console.log()</code>, <code>Window.alert()</code>. There is no direct way to call the Web APIs from WebAssembly, it has to go through JavaScript. As the WebAssembly team is working on improving this inefficiency, this situation is likely to change in the future.</p><p>The next logical question would be, <em>&#x201C;How is the data being passed between JavaScript VM and WebAssembly VM that makes the communication possible?&#x201D;</em>. They communicate by sharing memory &#x2014; both the VMs have access to a shared linear array of memory. The image below illustrates the scenario, where the WebAssembly module sends an ASCII encoded <code>Hello</code> message to the JavaScript module by writing it in the shared linear memory. In addition to the message, the WebAssembly module passes the starting address (offset) and the length of the message to the JavaScript module to read the data from the linear memory.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1400/1*tZZA79WzoEuIMRQ9MIOZDg.png" class="kg-image" alt loading="lazy"><figcaption>Image Credit: <a href="https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/" rel="noopener ugc nofollow">https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/</a></figcaption></figure><p>Thankfully, developers need not write low-level code to read and write from the linear memory and convert the data types between JavaScript and WebAssembly. Tools <code>emscripten</code> and <code>wasm-bindgen</code> will generate JavaScript glue code facilitating the communication between JavaScript and WebAssembly module.</p><h2 id="javascript-and-rust-generated-webassembly">JavaScript and Rust-generated WebAssembly</h2><p>In this section, let us take a code example to understand how data is transferred between JavaScript and WebAssembly. Rust is the language we will be using to build the WebAssembly module.</p><p>There are a few Rust elements we need to understand in the context of WebAssembly.</p><ol><li><code>wasm_bindgen</code> is a Rust library (crate) and also a Command Line Interface (CLI) tool that facilitates the high-level interaction between JavaScript and Rust-generated WebAssembly module. For example, Rust code can use native <code>&amp;str</code> type instead of a slice of <code>u32</code> to handle JavaScript String type. <code>wasm_bindgen</code> crate allows making calls to all the JavaScript and Web APIs from the Rust code.</li><li>When a public function or <code>extern</code> block is annotated with the attribute <code>#[wasm_bindgen]</code>, it tells the Rust WebAssembly compiler to generate the bindings and JavaScript glue code for the decorated function or a block.</li><li>There are a couple of meanings to the <code>extern</code> keyword in Rust. In the following context, the <code>extern</code> keyword is used to declare Foreign Function Interface (FFI) such that the Rust code can call those foreign functions.</li></ol><p>The following Rust code imports the Web API <code>Window.alert()</code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert" rel="noopener ugc nofollow"> </a>and exports the Rust function <code>greet</code> to JavaScript.</p><!--kg-card-begin: html--><script src="https://gist.github.com/AjithPanneerselvam/c70acb0601ace78b7db853be5eb1df2a.js"></script><!--kg-card-end: html--><p>Note that <code>greet</code> and <code>alert</code> functions accept native Rust type ( <code>&amp;str</code>) as a parameter and not a pointer to the linear memory. Thanks to <code>wasm-bindgen</code> for making this high-level interaction possible.</p><p><code>wasm-pack</code> is a popular tool to build WebAssembly packages written in Rust. <code>wasm-pack</code> internally uses <code>wasm-bindgen</code> to wrap out Rust-generated WebAssembly module by JavaScript wrappers. On building the above Rust code using <code>wasm-pack</code>, it generates the JavaScript wrappers to the WebAssembly module as shown in the image below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1400/1*JYXOcQ3s0xTL5dIL4knrdQ.png" class="kg-image" alt loading="lazy"><figcaption>JavaScript glue code generated by wasm-pack</figcaption></figure><p>The generated glue code allows the JavaScript application code to call the WebAssembly functions like calling any other JavaScript function. The following JavaScript code uses the generated glue code to call the <code>greet</code> function in the WebAssembly module and passes the argument <code>World!</code> of type string.</p><!--kg-card-begin: html--><script src="https://gist.github.com/AjithPanneerselvam/157828e0a374a3cbfdc95a7dd6bbf0ad.js"></script><!--kg-card-end: html--><p>Yay, we have successfully connected all the strings and the output is shown below.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1400/1*l-JS30JniJu9WNPbpGZ67A.png" class="kg-image" alt loading="lazy"><figcaption>Output</figcaption></figure><p>Let us go through the steps to understand what happens under the hood to achieve the above output.</p><ol><li>The string <code>World!</code> is passed to the JavaScript glue code from the JavaScript application code.</li><li>The JavaScript glue code converts the string into numbers (ASCII code) and writes in the linear memory.</li><li>JavaScript glue code also passes the length and pointer to the start of the message to WebAssembly.</li><li>WebAssembly reads the message (<code>World!</code> in ASCII code) from the linear memory and appends it to the ASCII equivalent of the string <code>Hello,</code> .</li><li>The Web API call <code>Window.alert()</code> from WebAssembly has to go through JavaScript. Hence, the ASCII values of the string <code>Hello, World!</code> are written to the linear memory and the starting address and length are passed to the JavaScript glue code.</li><li>JavaScript reads the message from the linear memory and decodes the ASCII values into JavaScript String.</li><li>JavaScript makes the Web API call <code>Window.alert()</code> and passes the argument <code>Hello, World!</code>.</li></ol><p>It is amazing to witness how well all the underlying complexities are abstracted away from the application code.</p><h2 id="some-inspirational-works-using-webassembly">Some inspirational works using WebAssembly</h2><ul><li><a href="https://www.wasm.com.cn/demo/Tanks/" rel="noopener ugc nofollow">Tanks game</a> by Unity.</li><li><a href="https://blogs.autodesk.com/autocad/autocad-web-app-google-io-2018/" rel="noopener ugc nofollow">AutoCAD Web Application</a>.</li><li><a href="https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6" rel="noopener">Google Earth</a> (WebAssembly made it possible for Google Earth to be available in all major browsers!!!).</li></ul><h2 id="resources">Resources</h2><p>There are tons of resources on the Internet that talk about WebAssembly in great breadth and depth. Some of the resources that I found useful are listed below.</p><ul><li><a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/" rel="noopener ugc nofollow">A cartoon intro to WebAssembly</a>, Lin Clark.</li><li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts" rel="noopener ugc nofollow">https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts</a></li><li><a href="https://2ality.com/2015/06/web-assembly.html" rel="noopener ugc nofollow">WebAssembly: a binary format for the web</a>, Axel Rauschmayer.</li><li><a href="https://rustwasm.github.io/wasm-bindgen/" rel="noopener ugc nofollow">wasm-bindgen Guide</a>.</li><li><a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/" rel="noopener ugc nofollow">Making WebAssembly even faster: Firefox&#x2019;s new streaming and tiering compiler</a>, Lin Clark.</li><li><a href="https://youtu.be/njt-Qzw0mVY" rel="noopener ugc nofollow">WebAssembly for Web Developers (Google I/O &#x2019;19)</a></li><li><a href="https://people.mpi-sws.org/~rossberg/papers/Haas,%20Rossberg,%20Schuff,%20Titzer,%20Gohman,%20Wagner,%20Zakai,%20Bastien,%20Holman%20-%20Bringing%20the%20Web%20up%20to%20Speed%20with%20WebAssembly.pdf" rel="noopener ugc nofollow">Bringing the Web up to Speed with WebAssembly</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Operating System Series - Process (Part I)]]></title><description><![CDATA[<p>This is the first blog post in the OS series. Without much thought, I decided to write about<strong> process</strong>, as it&apos;s the fundamental concept around which the other elements of OS are built.</p><p>Without any further introduction, let&apos;s dive in.</p><h3 id="what-is-a-process">What is a Process?</h3><p>First, let</p>]]></description><link>https://ajithpanneerselvam.github.io/operating-system-series-process-part-i/</link><guid isPermaLink="false">6218cbd3ca7339228dc03c59</guid><category><![CDATA[Operating System]]></category><dc:creator><![CDATA[Ajith]]></dc:creator><pubDate>Sat, 30 May 2020 12:38:00 GMT</pubDate><content:encoded><![CDATA[<p>This is the first blog post in the OS series. Without much thought, I decided to write about<strong> process</strong>, as it&apos;s the fundamental concept around which the other elements of OS are built.</p><p>Without any further introduction, let&apos;s dive in.</p><h3 id="what-is-a-process">What is a Process?</h3><p>First, let me provide a theoretical definition of &quot;process&quot; followed by practical illustrations. A process is a running instance of a program/code. Several processes can run in the same program, but each process has its own state. For example, you can open multiple instances of some applications like Firefox, Microsoft Word, etc. Each one maintains its own process state. A process executes the instructions sequentially (one at a time).</p><p>Let&apos;s see how the execution of a program looks in the memory with the following sample program.</p><figure class="kg-card kg-code-card"><pre><code class="language-c++">void foo(int f) {
	cout&lt;&lt;&quot;I&apos;m foo and my value is &quot;&lt;&lt; f; 
}

int main() {
	foo(5); 
	return 0;
}</code></pre><figcaption>foo.cpp</figcaption></figure><p>In the context of a process, the above program will look like the following diagram.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/pcb.png" class="kg-image" alt loading="lazy" width="950" height="670" srcset="https://ajithpanneerselvam.github.io/content/images/size/w600/2022/02/pcb.png 600w, https://ajithpanneerselvam.github.io/content/images/2022/02/pcb.png 950w" sizes="(min-width: 720px) 720px"><figcaption>Process Control Block</figcaption></figure><p><em>Note: The text segment will have assembly code or executable code. Just for the sake of illustration, I&apos;ve used high-level code.</em></p><p>As shown in the diagram, the program has to be organized in the following segments for execution.</p><p><strong>Data segment</strong></p><p>The data segment generally holds the global variables and the static variables of the program.</p><p><strong>Heap segment</strong></p><p>The dynamic allocation of memory is achieved by reserving a desired space in the heap memory. For example, in C++, when we do <em>new()</em> / <em>malloc()</em>, the process reserves the requested size from the heap segment. And, when we deallocate the memory by <em>free()</em>, the reserved space is given back to the heap memory marking it as free memory.</p><p><strong>Stack segment</strong></p><p>The stack segment holds the local variables, function parameters of each function. You can think of it as any state that needs to be maintained to execute a function, will be placed in that function&apos;s stack segment.</p><p><strong>Text segment</strong></p><p>The text segment holds the program or code in an executable format like assembly code. As it was already pointed out that a process executes the program sequentially, we have a pointer called <strong>Program Counter (PC)</strong> that points what&apos;s the next instruction to be executed.</p><h3 id="process-execution-state">Process Execution State</h3><p>Every process has a state attached to it, indicating what it is doing. There are five states in the process lifecycle. Each state is listed below.</p><ul><li><strong>New: </strong>OS creates a new process</li><li><strong>Running: </strong>executing instructions on the CPU</li><li><strong>Ready: </strong>ready to run, but waiting for the CPU</li><li><strong>Waiting: </strong>waiting for an event to complete (most I/O operation(s) of the Process).</li><li><strong>Terminated: </strong>OS destroys the process.</li></ul><p>As the program executes, it moves from state to state as a result of the program executions (e.g., system call), OS actions (scheduling), and external actions (interrupts).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/process-lifecycle.png" class="kg-image" alt loading="lazy"><figcaption>Process lifecycle</figcaption></figure><p>When a process moves from running state to waiting state, OS will give the CPU time to another process in the ready state in the meantime. The process moves to the waiting state when the OS schedules another process to execute on the CPU. Also, the process will go to the waiting state when it waits for the system call to complete.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/process-state-seq.png" class="kg-image" alt loading="lazy"><figcaption>Process state sequence with an example</figcaption></figure><h3 id="the-data-structure-of-a-process">The data structure of a Process</h3><p>The data structure used to maintain execution state, program counter, stack pointer, etc. is <strong>Process Control Block (PCB). </strong>OS allocates a new PCB on the creation of each process and places it on a state queue. The OS deallocates the PCB when the process terminates. The PCB holds the following for the execution of the process.</p><ul><li>Process State (running, waiting, etc.)</li><li>Process ID (pid)</li><li>Program Counter (PC)</li><li>Stack pointer</li><li>Register values</li><li>Memory management info</li><li>List of open files</li><li>Queue pointers for state queues</li><li>Scheduling info (e.g., priority)</li><li>I/O status</li></ul><p>Activity Monitor/Task Manager applications read the PCB table and show the process information to the users.</p><h3 id="process-state-queues">Process State Queues</h3><p>OS maintains the PCBs of all the processes in state queues. It places the PCBs of all the processes in the same execution state in the appropriate state queue. When the OS changes the state of a process, the PCB is unlinked from its current state queue and moved to its new state queue. <em>Each I/O device has its own wait queue. For example, when a group of processes is waiting for data to be fetched from a disk block, all those processes will be put in the disk waiting queue.</em></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/image.png" class="kg-image" alt loading="lazy" width="864" height="324" srcset="https://ajithpanneerselvam.github.io/content/images/size/w600/2022/02/image.png 600w, https://ajithpanneerselvam.github.io/content/images/2022/02/image.png 864w" sizes="(min-width: 720px) 720px"><figcaption>State Queues</figcaption></figure><p>The PCBs of the same state queue are linked together using a doubly-linked list.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/image-1.png" class="kg-image" alt loading="lazy" width="990" height="638" srcset="https://ajithpanneerselvam.github.io/content/images/size/w600/2022/02/image-1.png 600w, https://ajithpanneerselvam.github.io/content/images/2022/02/image-1.png 990w" sizes="(min-width: 720px) 720px"><figcaption>State queues with PCBs linked</figcaption></figure><p><em>Note: The size of the running queue will be equal to the number of CPU cores. The size of the other queues is unbounded.</em></p><p>This marks the end of process Part-I. In Part-II, we will further discuss the process context switch, parent, and child process.</p><p>Thanks for reading :)</p><p><strong>References</strong></p><figure class="kg-card kg-embed-card"><iframe width="200" height="113" src="https://www.youtube.com/embed/SfG_BefeGT4?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure>]]></content:encoded></item><item><title><![CDATA[Operating System Series]]></title><description><![CDATA[This is going to be my attempt to write a series of blogs on the theoretical aspects of Operating Systems, starting from the basics.]]></description><link>https://ajithpanneerselvam.github.io/a-journey-through-operating-systems/</link><guid isPermaLink="false">5eb0db6016ecd6d6ab98c3f3</guid><category><![CDATA[Operating System]]></category><dc:creator><![CDATA[Ajith]]></dc:creator><pubDate>Tue, 05 May 2020 03:25:00 GMT</pubDate><content:encoded><![CDATA[<p>This is going to be my attempt to write a series of blogs on the theoretical aspects of Operating Systems, starting from the basics.</p><p>This page will act as the index for the topics I cover in this series. I&apos;m planning to cover the below concepts (likely to add more). &#xA0;</p><ul><li>Process</li><li>Threads</li><li>CPU Scheduling</li><li>Memory management</li><li>Synchronization</li><li>I/O Management</li><li>File System</li></ul><p>I will keep this index updated and link it with each topic as and when I publish it.</p>]]></content:encoded></item><item><title><![CDATA[Finding Network Routing Path in Go]]></title><description><![CDATA[<p>This blog was published in the <a href="https://engineering.qubecinema.com/2019/05/13/go-routing-package.html">Qube Cinema Engineering blogs</a>.</p><p>This post shares our experience on finding a way to determine the network interfaces on a Linux Machine that provides the route to a particular remote machine. The use case would&#x2019;ve been a non-issue if the host machine</p>]]></description><link>https://ajithpanneerselvam.github.io/https-engineering-qubecinema-com-2019-05-13-go-routing-package-html/</link><guid isPermaLink="false">5eb0d85816ecd6d6ab98c3e1</guid><category><![CDATA[Go]]></category><category><![CDATA[Linux Networking]]></category><dc:creator><![CDATA[Ajith]]></dc:creator><pubDate>Mon, 13 May 2019 03:07:00 GMT</pubDate><content:encoded><![CDATA[<p>This blog was published in the <a href="https://engineering.qubecinema.com/2019/05/13/go-routing-package.html">Qube Cinema Engineering blogs</a>.</p><p>This post shares our experience on finding a way to determine the network interfaces on a Linux Machine that provides the route to a particular remote machine. The use case would&#x2019;ve been a non-issue if the host machine had a single network interface. But in our case, the host machine has multiple network interfaces bridging different networks. Though this problem seems to be a very trivial one on the first sight from the implementation point of view, the way the problem is solved easily in Golang is laudable.</p><p><em>If you are on the rush of finding the solution, scroll down all the way to the end.</em></p><p>We were developing a feature, in which, we had to configure the host machine IP address on a remote machine so that the remote machine can pull data at its ease. As the host machine is connected to multiple networks, the challenge is to identify the right network interface that is accessible by the remote machine and configure the corresponding IP address on the remote machine. If we fail to pass on the right network interface to the receiver, our whole purpose of building that feature will be collapsed. So it turned out to be an unprecedented requirement for us to solve.</p><p>For the purpose of illustration, let us assume that we have two networks connected to the machine and one of the two networks is a public network and the other is a private network.</p><figure class="kg-card kg-image-card"><img src="https://ajithpanneerselvam.github.io/content/images/2022/02/image-2.png" class="kg-image" alt loading="lazy" width="970" height="498" srcset="https://ajithpanneerselvam.github.io/content/images/size/w600/2022/02/image-2.png 600w, https://ajithpanneerselvam.github.io/content/images/2022/02/image-2.png 970w" sizes="(min-width: 720px) 720px"></figure><p>Given this setup, our goal was to find the network interface the packet takes to reach its destination. &#xA0;A bit of schooling - If a packet wants to reach a host located in a private network, will take <em>Network Interface 1</em> as its exit route, likewise a packet takes <em>Network Interface 2</em> to reach a host in public network.</p><p>Our first thought solution was to leverage the <a href="https://en.wikipedia.org/wiki/Routing_table">Routing table</a>. Fortuitously, we found the Linux command in no time to query the routing table to extract the desired information (network interface). By formatting the command with the destination host IP address we will be able to figure out the network interface a packet takes to reach the destination host. &#xA0;The <code>ip route</code> command looks like the command below.</p><pre><code>ip route get 172.217.160.132</code></pre><p>That seems to be an easy-peasy solution to the problem! Isn&#x2019;t it? Integrating the raw <code>ip route</code> command programmatically just as the snippet below solves the problem.</p><pre><code class="language-go">// cmd = &quot;ip route get 172.217.160.132&quot;
func exe_cmd(cmd string, wg *sync.WaitGroup) {
	parts := strings.Fields(cmd)
	head := parts[0]
	parts = parts[1:len(parts)]

	out, err := exec.Command(head, parts...).Output()
	if err != nil {
		fmt.Printf(&quot;%s&quot;, err)
	}
	
	fmt.Printf(&quot;%s&quot;, out)
	wg.Done()
}</code></pre><p>The output will look similar to the below output.</p><pre><code>172.217.160.132 via 172.17.0.1 dev eth1  src 172.17.0.2</code></pre><p>The caveat with this approach is that you have to parse the output string to extract out the necessary information. Unfortunately, this process will turn out to be more painful in case of any error like network going down or not connected to the internet. Even if it&#x2019;s plausible for us to parse for any possible output, it will eventually fail to meet the coding standards leaving the reviewers&#x2019; eyebrows frowned. &#xA0;We realized that we got to look for a neat and impeccable solution.</p><p>Further exploring led us to a very convincing solution in all the ways. The sub-package <a href="https://godoc.org/github.com/google/gopacket/routing">routing</a> of <a href="https://godoc.org/github.com/google/gopacket">gopacket</a> gave us everything that we felt wanting in the previous approach. &#xA0;It prevented our code to give a room for string parsing logic and escaped us from damaging the readability of the code. &#xA0;As an added bonus, we enjoyed the ease of handling any errors on using <code>routing</code> package.</p><p>Without anything stopping us further, we jumped on to using &#xA0;<code>routing</code> &#xA0;sub-package leaving the Linux Command approach as an ephemeral hero.</p><pre><code class="language-go">func determineRouteInterface(serverAddr string) error {
	var ip net.IP
	if ip = net.ParseIP(serverAddr); ip == nil {
		return fmt.Errorf(&quot;error as non-ip target %s is passed&quot;, serverAddr)
	}

	router, err := routing.New()
	if err != nil {
		return errors.Wrap(err, &quot;error while creating routing object&quot;)
	}

	_, gatewayIP, preferredSrc, err := router.Route(ip)
	if err != nil {
		return errors.Wrapf(err, &quot;error routing to ip: %s&quot;, serverAddr)
	}

	fmt.Printf(&quot;gatewayIP: %v preferredSrc: %v&quot;, gatewayIP, preferredSrc)
	return nil
}</code></pre><p>The output of the above code snippet will look similar to the below output.</p><pre><code>gatewayIP: 172.17.0.1 preferredSrc: 172.17.0.2</code></pre><p>With no surprise, the output is very neatly present eliminating the need for fancy string parsing logic.</p><p>In the first place, we were totally surprised to see a package available in Golang to query the routing table on a Linux machine. We understood that the problem of determining a network interface a packet takes to reach the destination is very rare and least underscored on the web. Hence, we decided to bring the <code>routing</code> package to the light. &#xA0;Indeed, this blog post was a result of our excitement on finding a package to fetch routing information from an underlying routing table on a Linux machine ;)</p>]]></content:encoded></item></channel></rss>